{"ast":null,"code":"\"use strict\";\n\nvar async_1 = require('../scheduler/async');\n\nvar isScheduler_1 = require('../util/isScheduler');\n\nvar bufferTime_1 = require('../operators/bufferTime');\n/* tslint:enable:max-line-length */\n\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * <img src=\"./img/bufferTime.png\" width=\"100%\">\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * @example <caption>Every second, emit an array of the recent click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(1000);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(2000, 5000);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferTime\n * @owner Observable\n */\n\n\nfunction bufferTime(bufferTimeSpan) {\n  var length = arguments.length;\n  var scheduler = async_1.async;\n\n  if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {\n    scheduler = arguments[arguments.length - 1];\n    length--;\n  }\n\n  var bufferCreationInterval = null;\n\n  if (length >= 2) {\n    bufferCreationInterval = arguments[1];\n  }\n\n  var maxBufferSize = Number.POSITIVE_INFINITY;\n\n  if (length >= 3) {\n    maxBufferSize = arguments[2];\n  }\n\n  return bufferTime_1.bufferTime(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler)(this);\n}\n\nexports.bufferTime = bufferTime;","map":{"version":3,"sources":["/app/node_modules/ng5-slider/node_modules/rxjs/operator/bufferTime.js"],"names":["async_1","require","isScheduler_1","bufferTime_1","bufferTime","bufferTimeSpan","length","arguments","scheduler","async","isScheduler","bufferCreationInterval","maxBufferSize","Number","POSITIVE_INFINITY","exports"],"mappings":"AAAA;;AACA,IAAIA,OAAO,GAAGC,OAAO,CAAC,oBAAD,CAArB;;AACA,IAAIC,aAAa,GAAGD,OAAO,CAAC,qBAAD,CAA3B;;AACA,IAAIE,YAAY,GAAGF,OAAO,CAAC,yBAAD,CAA1B;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,UAAT,CAAoBC,cAApB,EAAoC;AAChC,MAAIC,MAAM,GAAGC,SAAS,CAACD,MAAvB;AACA,MAAIE,SAAS,GAAGR,OAAO,CAACS,KAAxB;;AACA,MAAIP,aAAa,CAACQ,WAAd,CAA0BH,SAAS,CAACA,SAAS,CAACD,MAAV,GAAmB,CAApB,CAAnC,CAAJ,EAAgE;AAC5DE,IAAAA,SAAS,GAAGD,SAAS,CAACA,SAAS,CAACD,MAAV,GAAmB,CAApB,CAArB;AACAA,IAAAA,MAAM;AACT;;AACD,MAAIK,sBAAsB,GAAG,IAA7B;;AACA,MAAIL,MAAM,IAAI,CAAd,EAAiB;AACbK,IAAAA,sBAAsB,GAAGJ,SAAS,CAAC,CAAD,CAAlC;AACH;;AACD,MAAIK,aAAa,GAAGC,MAAM,CAACC,iBAA3B;;AACA,MAAIR,MAAM,IAAI,CAAd,EAAiB;AACbM,IAAAA,aAAa,GAAGL,SAAS,CAAC,CAAD,CAAzB;AACH;;AACD,SAAOJ,YAAY,CAACC,UAAb,CAAwBC,cAAxB,EAAwCM,sBAAxC,EAAgEC,aAAhE,EAA+EJ,SAA/E,EAA0F,IAA1F,CAAP;AACH;;AACDO,OAAO,CAACX,UAAR,GAAqBA,UAArB","sourcesContent":["\"use strict\";\nvar async_1 = require('../scheduler/async');\nvar isScheduler_1 = require('../util/isScheduler');\nvar bufferTime_1 = require('../operators/bufferTime');\n/* tslint:enable:max-line-length */\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * <img src=\"./img/bufferTime.png\" width=\"100%\">\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * @example <caption>Every second, emit an array of the recent click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(1000);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(2000, 5000);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferTime\n * @owner Observable\n */\nfunction bufferTime(bufferTimeSpan) {\n    var length = arguments.length;\n    var scheduler = async_1.async;\n    if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {\n        scheduler = arguments[arguments.length - 1];\n        length--;\n    }\n    var bufferCreationInterval = null;\n    if (length >= 2) {\n        bufferCreationInterval = arguments[1];\n    }\n    var maxBufferSize = Number.POSITIVE_INFINITY;\n    if (length >= 3) {\n        maxBufferSize = arguments[2];\n    }\n    return bufferTime_1.bufferTime(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler)(this);\n}\nexports.bufferTime = bufferTime;\n"]},"metadata":{},"sourceType":"script"}