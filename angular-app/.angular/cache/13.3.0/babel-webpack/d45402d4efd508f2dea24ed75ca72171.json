{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = require('../Observable');\n\nvar tryCatch_1 = require('../util/tryCatch');\n\nvar errorObject_1 = require('../util/errorObject');\n\nvar AsyncSubject_1 = require('../AsyncSubject');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar BoundCallbackObservable = function (_super) {\n  __extends(BoundCallbackObservable, _super);\n\n  function BoundCallbackObservable(callbackFunc, selector, args, context, scheduler) {\n    _super.call(this);\n\n    this.callbackFunc = callbackFunc;\n    this.selector = selector;\n    this.args = args;\n    this.context = context;\n    this.scheduler = scheduler;\n  }\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Converts a callback API to a function that returns an Observable.\n   *\n   * <span class=\"informal\">Give it a function `f` of type `f(x, callback)` and\n   * it will return a function `g` that when called as `g(x)` will output an\n   * Observable.</span>\n   *\n   * `bindCallback` is not an operator because its input and output are not\n   * Observables. The input is a function `func` with some parameters, the\n   * last parameter must be a callback function that `func` calls when it is\n   * done.\n   *\n   * The output of `bindCallback` is a function that takes the same parameters\n   * as `func`, except the last one (the callback). When the output function\n   * is called with arguments it will return an Observable. If function `func`\n   * calls its callback with one argument the Observable will emit that value.\n   * If on the other hand the callback is called with multiple values the resulting\n   * Observable will emit an array with said values as arguments.\n   *\n   * It is very important to remember that input function `func` is not called\n   * when the output function is, but rather when the Observable returned by the output\n   * function is subscribed. This means if `func` makes an AJAX request, that request\n   * will be made every time someone subscribes to the resulting Observable, but not before.\n   *\n   * Optionally, a selector function can be passed to `bindObservable`. The selector function\n   * takes the same arguments as the callback and returns the value that will be emitted by the Observable.\n   * Even though by default multiple arguments passed to callback appear in the stream as an array\n   * the selector function will be called with arguments directly, just as the callback would.\n   * This means you can imagine the default selector (when one is not provided explicitly)\n   * as a function that aggregates all its arguments into an array, or simply returns first argument\n   * if there is only one.\n   *\n   * The last optional parameter - {@link Scheduler} - can be used to control when the call\n   * to `func` happens after someone subscribes to Observable, as well as when results\n   * passed to callback will be emitted. By default, the subscription to  an Observable calls `func`\n   * synchronously, but using `Scheduler.async` as the last parameter will defer the call to `func`,\n   * just like wrapping the call in `setTimeout` with a timeout of `0` would. If you use the async Scheduler\n   * and call `subscribe` on the output Observable all function calls that are currently executing\n   * will end before `func` is invoked.\n   *\n   * By default results passed to the callback are emitted immediately after `func` invokes the callback.\n   * In particular, if the callback is called synchronously the subscription of the resulting Observable\n   * will call the `next` function synchronously as well.  If you want to defer that call,\n   * you may use `Scheduler.async` just as before.  This means that by using `Scheduler.async` you can\n   * ensure that `func` always calls its callback asynchronously, thus avoiding terrifying Zalgo.\n   *\n   * Note that the Observable created by the output function will always emit a single value\n   * and then complete immediately. If `func` calls the callback multiple times, values from subsequent\n   * calls will not appear in the stream. If you need to listen for multiple calls,\n   *  you probably want to use {@link fromEvent} or {@link fromEventPattern} instead.\n   *\n   * If `func` depends on some context (`this` property) and is not already bound the context of `func`\n   * will be the context that the output function has at call time. In particular, if `func`\n   * is called as a method of some objec and if `func` is not already bound, in order to preserve the context\n   * it is recommended that the context of the output function is set to that object as well.\n   *\n   * If the input function calls its callback in the \"node style\" (i.e. first argument to callback is\n   * optional error parameter signaling whether the call failed or not), {@link bindNodeCallback}\n   * provides convenient error handling and probably is a better choice.\n   * `bindCallback` will treat such functions the same as any other and error parameters\n   * (whether passed or not) will always be interpreted as regular callback argument.\n   *\n   *\n   * @example <caption>Convert jQuery's getJSON to an Observable API</caption>\n   * // Suppose we have jQuery.getJSON('/my/url', callback)\n   * var getJSONAsObservable = Rx.Observable.bindCallback(jQuery.getJSON);\n   * var result = getJSONAsObservable('/my/url');\n   * result.subscribe(x => console.log(x), e => console.error(e));\n   *\n   *\n   * @example <caption>Receive an array of arguments passed to a callback</caption>\n   * someFunction((a, b, c) => {\n   *   console.log(a); // 5\n   *   console.log(b); // 'some string'\n   *   console.log(c); // {someProperty: 'someValue'}\n   * });\n   *\n   * const boundSomeFunction = Rx.Observable.bindCallback(someFunction);\n   * boundSomeFunction().subscribe(values => {\n   *   console.log(values) // [5, 'some string', {someProperty: 'someValue'}]\n   * });\n   *\n   *\n   * @example <caption>Use bindCallback with a selector function</caption>\n   * someFunction((a, b, c) => {\n   *   console.log(a); // 'a'\n   *   console.log(b); // 'b'\n   *   console.log(c); // 'c'\n   * });\n   *\n   * const boundSomeFunction = Rx.Observable.bindCallback(someFunction, (a, b, c) => a + b + c);\n   * boundSomeFunction().subscribe(value => {\n   *   console.log(value) // 'abc'\n   * });\n   *\n   *\n   * @example <caption>Compare behaviour with and without async Scheduler</caption>\n   * function iCallMyCallbackSynchronously(cb) {\n   *   cb();\n   * }\n   *\n   * const boundSyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously);\n   * const boundAsyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously, null, Rx.Scheduler.async);\n   *\n   * boundSyncFn().subscribe(() => console.log('I was sync!'));\n   * boundAsyncFn().subscribe(() => console.log('I was async!'));\n   * console.log('This happened...');\n   *\n   * // Logs:\n   * // I was sync!\n   * // This happened...\n   * // I was async!\n   *\n   *\n   * @example <caption>Use bindCallback on an object method</caption>\n   * const boundMethod = Rx.Observable.bindCallback(someObject.methodWithCallback);\n   * boundMethod.call(someObject) // make sure methodWithCallback has access to someObject\n   * .subscribe(subscriber);\n   *\n   *\n   * @see {@link bindNodeCallback}\n   * @see {@link from}\n   * @see {@link fromPromise}\n   *\n   * @param {function} func A function with a callback as the last parameter.\n   * @param {function} [selector] A function which takes the arguments from the\n   * callback and maps them to a value that is emitted on the output Observable.\n   * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n   * callbacks.\n   * @return {function(...params: *): Observable} A function which returns the\n   * Observable that delivers the same values the callback would deliver.\n   * @static true\n   * @name bindCallback\n   * @owner Observable\n   */\n\n\n  BoundCallbackObservable.create = function (func, selector, scheduler) {\n    if (selector === void 0) {\n      selector = undefined;\n    }\n\n    return function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n      }\n\n      return new BoundCallbackObservable(func, selector, args, this, scheduler);\n    };\n  };\n  /** @deprecated internal use only */\n\n\n  BoundCallbackObservable.prototype._subscribe = function (subscriber) {\n    var callbackFunc = this.callbackFunc;\n    var args = this.args;\n    var scheduler = this.scheduler;\n    var subject = this.subject;\n\n    if (!scheduler) {\n      if (!subject) {\n        subject = this.subject = new AsyncSubject_1.AsyncSubject();\n\n        var handler = function handlerFn() {\n          var innerArgs = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            innerArgs[_i - 0] = arguments[_i];\n          }\n\n          var source = handlerFn.source;\n          var selector = source.selector,\n              subject = source.subject;\n\n          if (selector) {\n            var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n\n            if (result_1 === errorObject_1.errorObject) {\n              subject.error(errorObject_1.errorObject.e);\n            } else {\n              subject.next(result_1);\n              subject.complete();\n            }\n          } else {\n            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n            subject.complete();\n          }\n        }; // use named function instance to avoid closure.\n\n\n        handler.source = this;\n        var result = tryCatch_1.tryCatch(callbackFunc).apply(this.context, args.concat(handler));\n\n        if (result === errorObject_1.errorObject) {\n          subject.error(errorObject_1.errorObject.e);\n        }\n      }\n\n      return subject.subscribe(subscriber);\n    } else {\n      return scheduler.schedule(BoundCallbackObservable.dispatch, 0, {\n        source: this,\n        subscriber: subscriber,\n        context: this.context\n      });\n    }\n  };\n\n  BoundCallbackObservable.dispatch = function (state) {\n    var self = this;\n    var source = state.source,\n        subscriber = state.subscriber,\n        context = state.context;\n    var callbackFunc = source.callbackFunc,\n        args = source.args,\n        scheduler = source.scheduler;\n    var subject = source.subject;\n\n    if (!subject) {\n      subject = source.subject = new AsyncSubject_1.AsyncSubject();\n\n      var handler = function handlerFn() {\n        var innerArgs = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          innerArgs[_i - 0] = arguments[_i];\n        }\n\n        var source = handlerFn.source;\n        var selector = source.selector,\n            subject = source.subject;\n\n        if (selector) {\n          var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n\n          if (result_2 === errorObject_1.errorObject) {\n            self.add(scheduler.schedule(dispatchError, 0, {\n              err: errorObject_1.errorObject.e,\n              subject: subject\n            }));\n          } else {\n            self.add(scheduler.schedule(dispatchNext, 0, {\n              value: result_2,\n              subject: subject\n            }));\n          }\n        } else {\n          var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n          self.add(scheduler.schedule(dispatchNext, 0, {\n            value: value,\n            subject: subject\n          }));\n        }\n      }; // use named function to pass values in without closure\n\n\n      handler.source = source;\n      var result = tryCatch_1.tryCatch(callbackFunc).apply(context, args.concat(handler));\n\n      if (result === errorObject_1.errorObject) {\n        subject.error(errorObject_1.errorObject.e);\n      }\n    }\n\n    self.add(subject.subscribe(subscriber));\n  };\n\n  return BoundCallbackObservable;\n}(Observable_1.Observable);\n\nexports.BoundCallbackObservable = BoundCallbackObservable;\n\nfunction dispatchNext(arg) {\n  var value = arg.value,\n      subject = arg.subject;\n  subject.next(value);\n  subject.complete();\n}\n\nfunction dispatchError(arg) {\n  var err = arg.err,\n      subject = arg.subject;\n  subject.error(err);\n}","map":{"version":3,"sources":["/app/node_modules/ng5-slider/node_modules/rxjs/observable/BoundCallbackObservable.js"],"names":["__extends","d","b","p","hasOwnProperty","__","constructor","prototype","Object","create","Observable_1","require","tryCatch_1","errorObject_1","AsyncSubject_1","BoundCallbackObservable","_super","callbackFunc","selector","args","context","scheduler","call","func","undefined","_i","arguments","length","_subscribe","subscriber","subject","AsyncSubject","handler","handlerFn","innerArgs","source","result_1","tryCatch","apply","errorObject","error","e","next","complete","result","concat","subscribe","schedule","dispatch","state","self","result_2","add","dispatchError","err","dispatchNext","value","Observable","exports","arg"],"mappings":"AAAA;;AACA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA4B,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AACxD,OAAK,IAAIC,CAAT,IAAcD,CAAd,EAAiB,IAAIA,CAAC,CAACE,cAAF,CAAiBD,CAAjB,CAAJ,EAAyBF,CAAC,CAACE,CAAD,CAAD,GAAOD,CAAC,CAACC,CAAD,CAAR;;AAC1C,WAASE,EAAT,GAAc;AAAE,SAAKC,WAAL,GAAmBL,CAAnB;AAAuB;;AACvCA,EAAAA,CAAC,CAACM,SAAF,GAAcL,CAAC,KAAK,IAAN,GAAaM,MAAM,CAACC,MAAP,CAAcP,CAAd,CAAb,IAAiCG,EAAE,CAACE,SAAH,GAAeL,CAAC,CAACK,SAAjB,EAA4B,IAAIF,EAAJ,EAA7D,CAAd;AACH,CAJD;;AAKA,IAAIK,YAAY,GAAGC,OAAO,CAAC,eAAD,CAA1B;;AACA,IAAIC,UAAU,GAAGD,OAAO,CAAC,kBAAD,CAAxB;;AACA,IAAIE,aAAa,GAAGF,OAAO,CAAC,qBAAD,CAA3B;;AACA,IAAIG,cAAc,GAAGH,OAAO,CAAC,iBAAD,CAA5B;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAII,uBAAuB,GAAI,UAAUC,MAAV,EAAkB;AAC7ChB,EAAAA,SAAS,CAACe,uBAAD,EAA0BC,MAA1B,CAAT;;AACA,WAASD,uBAAT,CAAiCE,YAAjC,EAA+CC,QAA/C,EAAyDC,IAAzD,EAA+DC,OAA/D,EAAwEC,SAAxE,EAAmF;AAC/EL,IAAAA,MAAM,CAACM,IAAP,CAAY,IAAZ;;AACA,SAAKL,YAAL,GAAoBA,YAApB;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACH;AACD;;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIN,EAAAA,uBAAuB,CAACN,MAAxB,GAAiC,UAAUc,IAAV,EAAgBL,QAAhB,EAA0BG,SAA1B,EAAqC;AAClE,QAAIH,QAAQ,KAAK,KAAK,CAAtB,EAAyB;AAAEA,MAAAA,QAAQ,GAAGM,SAAX;AAAuB;;AAClD,WAAO,YAAY;AACf,UAAIL,IAAI,GAAG,EAAX;;AACA,WAAK,IAAIM,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGC,SAAS,CAACC,MAAhC,EAAwCF,EAAE,EAA1C,EAA8C;AAC1CN,QAAAA,IAAI,CAACM,EAAE,GAAG,CAAN,CAAJ,GAAeC,SAAS,CAACD,EAAD,CAAxB;AACH;;AACD,aAAO,IAAIV,uBAAJ,CAA4BQ,IAA5B,EAAkCL,QAAlC,EAA4CC,IAA5C,EAAkD,IAAlD,EAAwDE,SAAxD,CAAP;AACH,KAND;AAOH,GATD;AAUA;;;AAAqCN,EAAAA,uBAAuB,CAACR,SAAxB,CAAkCqB,UAAlC,GAA+C,UAAUC,UAAV,EAAsB;AACtG,QAAIZ,YAAY,GAAG,KAAKA,YAAxB;AACA,QAAIE,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAIE,SAAS,GAAG,KAAKA,SAArB;AACA,QAAIS,OAAO,GAAG,KAAKA,OAAnB;;AACA,QAAI,CAACT,SAA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","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar AsyncSubject_1 = require('../AsyncSubject');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar BoundCallbackObservable = (function (_super) {\n    __extends(BoundCallbackObservable, _super);\n    function BoundCallbackObservable(callbackFunc, selector, args, context, scheduler) {\n        _super.call(this);\n        this.callbackFunc = callbackFunc;\n        this.selector = selector;\n        this.args = args;\n        this.context = context;\n        this.scheduler = scheduler;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Converts a callback API to a function that returns an Observable.\n     *\n     * <span class=\"informal\">Give it a function `f` of type `f(x, callback)` and\n     * it will return a function `g` that when called as `g(x)` will output an\n     * Observable.</span>\n     *\n     * `bindCallback` is not an operator because its input and output are not\n     * Observables. The input is a function `func` with some parameters, the\n     * last parameter must be a callback function that `func` calls when it is\n     * done.\n     *\n     * The output of `bindCallback` is a function that takes the same parameters\n     * as `func`, except the last one (the callback). When the output function\n     * is called with arguments it will return an Observable. If function `func`\n     * calls its callback with one argument the Observable will emit that value.\n     * If on the other hand the callback is called with multiple values the resulting\n     * Observable will emit an array with said values as arguments.\n     *\n     * It is very important to remember that input function `func` is not called\n     * when the output function is, but rather when the Observable returned by the output\n     * function is subscribed. This means if `func` makes an AJAX request, that request\n     * will be made every time someone subscribes to the resulting Observable, but not before.\n     *\n     * Optionally, a selector function can be passed to `bindObservable`. The selector function\n     * takes the same arguments as the callback and returns the value that will be emitted by the Observable.\n     * Even though by default multiple arguments passed to callback appear in the stream as an array\n     * the selector function will be called with arguments directly, just as the callback would.\n     * This means you can imagine the default selector (when one is not provided explicitly)\n     * as a function that aggregates all its arguments into an array, or simply returns first argument\n     * if there is only one.\n     *\n     * The last optional parameter - {@link Scheduler} - can be used to control when the call\n     * to `func` happens after someone subscribes to Observable, as well as when results\n     * passed to callback will be emitted. By default, the subscription to  an Observable calls `func`\n     * synchronously, but using `Scheduler.async` as the last parameter will defer the call to `func`,\n     * just like wrapping the call in `setTimeout` with a timeout of `0` would. If you use the async Scheduler\n     * and call `subscribe` on the output Observable all function calls that are currently executing\n     * will end before `func` is invoked.\n     *\n     * By default results passed to the callback are emitted immediately after `func` invokes the callback.\n     * In particular, if the callback is called synchronously the subscription of the resulting Observable\n     * will call the `next` function synchronously as well.  If you want to defer that call,\n     * you may use `Scheduler.async` just as before.  This means that by using `Scheduler.async` you can\n     * ensure that `func` always calls its callback asynchronously, thus avoiding terrifying Zalgo.\n     *\n     * Note that the Observable created by the output function will always emit a single value\n     * and then complete immediately. If `func` calls the callback multiple times, values from subsequent\n     * calls will not appear in the stream. If you need to listen for multiple calls,\n     *  you probably want to use {@link fromEvent} or {@link fromEventPattern} instead.\n     *\n     * If `func` depends on some context (`this` property) and is not already bound the context of `func`\n     * will be the context that the output function has at call time. In particular, if `func`\n     * is called as a method of some objec and if `func` is not already bound, in order to preserve the context\n     * it is recommended that the context of the output function is set to that object as well.\n     *\n     * If the input function calls its callback in the \"node style\" (i.e. first argument to callback is\n     * optional error parameter signaling whether the call failed or not), {@link bindNodeCallback}\n     * provides convenient error handling and probably is a better choice.\n     * `bindCallback` will treat such functions the same as any other and error parameters\n     * (whether passed or not) will always be interpreted as regular callback argument.\n     *\n     *\n     * @example <caption>Convert jQuery's getJSON to an Observable API</caption>\n     * // Suppose we have jQuery.getJSON('/my/url', callback)\n     * var getJSONAsObservable = Rx.Observable.bindCallback(jQuery.getJSON);\n     * var result = getJSONAsObservable('/my/url');\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     *\n     * @example <caption>Receive an array of arguments passed to a callback</caption>\n     * someFunction((a, b, c) => {\n     *   console.log(a); // 5\n     *   console.log(b); // 'some string'\n     *   console.log(c); // {someProperty: 'someValue'}\n     * });\n     *\n     * const boundSomeFunction = Rx.Observable.bindCallback(someFunction);\n     * boundSomeFunction().subscribe(values => {\n     *   console.log(values) // [5, 'some string', {someProperty: 'someValue'}]\n     * });\n     *\n     *\n     * @example <caption>Use bindCallback with a selector function</caption>\n     * someFunction((a, b, c) => {\n     *   console.log(a); // 'a'\n     *   console.log(b); // 'b'\n     *   console.log(c); // 'c'\n     * });\n     *\n     * const boundSomeFunction = Rx.Observable.bindCallback(someFunction, (a, b, c) => a + b + c);\n     * boundSomeFunction().subscribe(value => {\n     *   console.log(value) // 'abc'\n     * });\n     *\n     *\n     * @example <caption>Compare behaviour with and without async Scheduler</caption>\n     * function iCallMyCallbackSynchronously(cb) {\n     *   cb();\n     * }\n     *\n     * const boundSyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously);\n     * const boundAsyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously, null, Rx.Scheduler.async);\n     *\n     * boundSyncFn().subscribe(() => console.log('I was sync!'));\n     * boundAsyncFn().subscribe(() => console.log('I was async!'));\n     * console.log('This happened...');\n     *\n     * // Logs:\n     * // I was sync!\n     * // This happened...\n     * // I was async!\n     *\n     *\n     * @example <caption>Use bindCallback on an object method</caption>\n     * const boundMethod = Rx.Observable.bindCallback(someObject.methodWithCallback);\n     * boundMethod.call(someObject) // make sure methodWithCallback has access to someObject\n     * .subscribe(subscriber);\n     *\n     *\n     * @see {@link bindNodeCallback}\n     * @see {@link from}\n     * @see {@link fromPromise}\n     *\n     * @param {function} func A function with a callback as the last parameter.\n     * @param {function} [selector] A function which takes the arguments from the\n     * callback and maps them to a value that is emitted on the output Observable.\n     * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n     * callbacks.\n     * @return {function(...params: *): Observable} A function which returns the\n     * Observable that delivers the same values the callback would deliver.\n     * @static true\n     * @name bindCallback\n     * @owner Observable\n     */\n    BoundCallbackObservable.create = function (func, selector, scheduler) {\n        if (selector === void 0) { selector = undefined; }\n        return function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            return new BoundCallbackObservable(func, selector, args, this, scheduler);\n        };\n    };\n    /** @deprecated internal use only */ BoundCallbackObservable.prototype._subscribe = function (subscriber) {\n        var callbackFunc = this.callbackFunc;\n        var args = this.args;\n        var scheduler = this.scheduler;\n        var subject = this.subject;\n        if (!scheduler) {\n            if (!subject) {\n                subject = this.subject = new AsyncSubject_1.AsyncSubject();\n                var handler = function handlerFn() {\n                    var innerArgs = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        innerArgs[_i - 0] = arguments[_i];\n                    }\n                    var source = handlerFn.source;\n                    var selector = source.selector, subject = source.subject;\n                    if (selector) {\n                        var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n                        if (result_1 === errorObject_1.errorObject) {\n                            subject.error(errorObject_1.errorObject.e);\n                        }\n                        else {\n                            subject.next(result_1);\n                            subject.complete();\n                        }\n                    }\n                    else {\n                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n                        subject.complete();\n                    }\n                };\n                // use named function instance to avoid closure.\n                handler.source = this;\n                var result = tryCatch_1.tryCatch(callbackFunc).apply(this.context, args.concat(handler));\n                if (result === errorObject_1.errorObject) {\n                    subject.error(errorObject_1.errorObject.e);\n                }\n            }\n            return subject.subscribe(subscriber);\n        }\n        else {\n            return scheduler.schedule(BoundCallbackObservable.dispatch, 0, { source: this, subscriber: subscriber, context: this.context });\n        }\n    };\n    BoundCallbackObservable.dispatch = function (state) {\n        var self = this;\n        var source = state.source, subscriber = state.subscriber, context = state.context;\n        var callbackFunc = source.callbackFunc, args = source.args, scheduler = source.scheduler;\n        var subject = source.subject;\n        if (!subject) {\n            subject = source.subject = new AsyncSubject_1.AsyncSubject();\n            var handler = function handlerFn() {\n                var innerArgs = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    innerArgs[_i - 0] = arguments[_i];\n                }\n                var source = handlerFn.source;\n                var selector = source.selector, subject = source.subject;\n                if (selector) {\n                    var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n                    if (result_2 === errorObject_1.errorObject) {\n                        self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));\n                    }\n                    else {\n                        self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));\n                    }\n                }\n                else {\n                    var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n                    self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));\n                }\n            };\n            // use named function to pass values in without closure\n            handler.source = source;\n            var result = tryCatch_1.tryCatch(callbackFunc).apply(context, args.concat(handler));\n            if (result === errorObject_1.errorObject) {\n                subject.error(errorObject_1.errorObject.e);\n            }\n        }\n        self.add(subject.subscribe(subscriber));\n    };\n    return BoundCallbackObservable;\n}(Observable_1.Observable));\nexports.BoundCallbackObservable = BoundCallbackObservable;\nfunction dispatchNext(arg) {\n    var value = arg.value, subject = arg.subject;\n    subject.next(value);\n    subject.complete();\n}\nfunction dispatchError(arg) {\n    var err = arg.err, subject = arg.subject;\n    subject.error(err);\n}\n"]},"metadata":{},"sourceType":"script"}