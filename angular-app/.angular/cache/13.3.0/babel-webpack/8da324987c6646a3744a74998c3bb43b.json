{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar async_1 = require('../scheduler/async');\n\nvar Subscriber_1 = require('../Subscriber');\n\nvar isScheduler_1 = require('../util/isScheduler');\n/* tslint:enable:max-line-length */\n\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * <img src=\"./img/bufferTime.png\" width=\"100%\">\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * @example <caption>Every second, emit an array of the recent click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(1000);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(2000, 5000);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferTime\n * @owner Observable\n */\n\n\nfunction bufferTime(bufferTimeSpan) {\n  var length = arguments.length;\n  var scheduler = async_1.async;\n\n  if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {\n    scheduler = arguments[arguments.length - 1];\n    length--;\n  }\n\n  var bufferCreationInterval = null;\n\n  if (length >= 2) {\n    bufferCreationInterval = arguments[1];\n  }\n\n  var maxBufferSize = Number.POSITIVE_INFINITY;\n\n  if (length >= 3) {\n    maxBufferSize = arguments[2];\n  }\n\n  return function bufferTimeOperatorFunction(source) {\n    return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n  };\n}\n\nexports.bufferTime = bufferTime;\n\nvar BufferTimeOperator = function () {\n  function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    this.bufferTimeSpan = bufferTimeSpan;\n    this.bufferCreationInterval = bufferCreationInterval;\n    this.maxBufferSize = maxBufferSize;\n    this.scheduler = scheduler;\n  }\n\n  BufferTimeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n  };\n\n  return BufferTimeOperator;\n}();\n\nvar Context = function () {\n  function Context() {\n    this.buffer = [];\n  }\n\n  return Context;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar BufferTimeSubscriber = function (_super) {\n  __extends(BufferTimeSubscriber, _super);\n\n  function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    _super.call(this, destination);\n\n    this.bufferTimeSpan = bufferTimeSpan;\n    this.bufferCreationInterval = bufferCreationInterval;\n    this.maxBufferSize = maxBufferSize;\n    this.scheduler = scheduler;\n    this.contexts = [];\n    var context = this.openContext();\n    this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n\n    if (this.timespanOnly) {\n      var timeSpanOnlyState = {\n        subscriber: this,\n        context: context,\n        bufferTimeSpan: bufferTimeSpan\n      };\n      this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    } else {\n      var closeState = {\n        subscriber: this,\n        context: context\n      };\n      var creationState = {\n        bufferTimeSpan: bufferTimeSpan,\n        bufferCreationInterval: bufferCreationInterval,\n        subscriber: this,\n        scheduler: scheduler\n      };\n      this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n      this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n    }\n  }\n\n  BufferTimeSubscriber.prototype._next = function (value) {\n    var contexts = this.contexts;\n    var len = contexts.length;\n    var filledBufferContext;\n\n    for (var i = 0; i < len; i++) {\n      var context = contexts[i];\n      var buffer = context.buffer;\n      buffer.push(value);\n\n      if (buffer.length == this.maxBufferSize) {\n        filledBufferContext = context;\n      }\n    }\n\n    if (filledBufferContext) {\n      this.onBufferFull(filledBufferContext);\n    }\n  };\n\n  BufferTimeSubscriber.prototype._error = function (err) {\n    this.contexts.length = 0;\n\n    _super.prototype._error.call(this, err);\n  };\n\n  BufferTimeSubscriber.prototype._complete = function () {\n    var _a = this,\n        contexts = _a.contexts,\n        destination = _a.destination;\n\n    while (contexts.length > 0) {\n      var context = contexts.shift();\n      destination.next(context.buffer);\n    }\n\n    _super.prototype._complete.call(this);\n  };\n  /** @deprecated internal use only */\n\n\n  BufferTimeSubscriber.prototype._unsubscribe = function () {\n    this.contexts = null;\n  };\n\n  BufferTimeSubscriber.prototype.onBufferFull = function (context) {\n    this.closeContext(context);\n    var closeAction = context.closeAction;\n    closeAction.unsubscribe();\n    this.remove(closeAction);\n\n    if (!this.closed && this.timespanOnly) {\n      context = this.openContext();\n      var bufferTimeSpan = this.bufferTimeSpan;\n      var timeSpanOnlyState = {\n        subscriber: this,\n        context: context,\n        bufferTimeSpan: bufferTimeSpan\n      };\n      this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    }\n  };\n\n  BufferTimeSubscriber.prototype.openContext = function () {\n    var context = new Context();\n    this.contexts.push(context);\n    return context;\n  };\n\n  BufferTimeSubscriber.prototype.closeContext = function (context) {\n    this.destination.next(context.buffer);\n    var contexts = this.contexts;\n    var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n\n    if (spliceIndex >= 0) {\n      contexts.splice(contexts.indexOf(context), 1);\n    }\n  };\n\n  return BufferTimeSubscriber;\n}(Subscriber_1.Subscriber);\n\nfunction dispatchBufferTimeSpanOnly(state) {\n  var subscriber = state.subscriber;\n  var prevContext = state.context;\n\n  if (prevContext) {\n    subscriber.closeContext(prevContext);\n  }\n\n  if (!subscriber.closed) {\n    state.context = subscriber.openContext();\n    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n  }\n}\n\nfunction dispatchBufferCreation(state) {\n  var bufferCreationInterval = state.bufferCreationInterval,\n      bufferTimeSpan = state.bufferTimeSpan,\n      subscriber = state.subscriber,\n      scheduler = state.scheduler;\n  var context = subscriber.openContext();\n  var action = this;\n\n  if (!subscriber.closed) {\n    subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, {\n      subscriber: subscriber,\n      context: context\n    }));\n    action.schedule(state, bufferCreationInterval);\n  }\n}\n\nfunction dispatchBufferClose(arg) {\n  var subscriber = arg.subscriber,\n      context = arg.context;\n  subscriber.closeContext(context);\n}","map":{"version":3,"sources":["/app/node_modules/ng5-slider/node_modules/rxjs/operators/bufferTime.js"],"names":["__extends","d","b","p","hasOwnProperty","__","constructor","prototype","Object","create","async_1","require","Subscriber_1","isScheduler_1","bufferTime","bufferTimeSpan","length","arguments","scheduler","async","isScheduler","bufferCreationInterval","maxBufferSize","Number","POSITIVE_INFINITY","bufferTimeOperatorFunction","source","lift","BufferTimeOperator","exports","call","subscriber","subscribe","BufferTimeSubscriber","Context","buffer","_super","destination","contexts","context","openContext","timespanOnly","timeSpanOnlyState","add","closeAction","schedule","dispatchBufferTimeSpanOnly","closeState","creationState","dispatchBufferClose","dispatchBufferCreation","_next","value","len","filledBufferContext","i","push","onBufferFull","_error","err","_complete","_a","shift","next","_unsubscribe","closeContext","unsubscribe","remove","closed","spliceIndex","indexOf","splice","Subscriber","state","prevContext","action","arg"],"mappings":"AAAA;;AACA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA4B,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AACxD,OAAK,IAAIC,CAAT,IAAcD,CAAd,EAAiB,IAAIA,CAAC,CAACE,cAAF,CAAiBD,CAAjB,CAAJ,EAAyBF,CAAC,CAACE,CAAD,CAAD,GAAOD,CAAC,CAACC,CAAD,CAAR;;AAC1C,WAASE,EAAT,GAAc;AAAE,SAAKC,WAAL,GAAmBL,CAAnB;AAAuB;;AACvCA,EAAAA,CAAC,CAACM,SAAF,GAAcL,CAAC,KAAK,IAAN,GAAaM,MAAM,CAACC,MAAP,CAAcP,CAAd,CAAb,IAAiCG,EAAE,CAACE,SAAH,GAAeL,CAAC,CAACK,SAAjB,EAA4B,IAAIF,EAAJ,EAA7D,CAAd;AACH,CAJD;;AAKA,IAAIK,OAAO,GAAGC,OAAO,CAAC,oBAAD,CAArB;;AACA,IAAIC,YAAY,GAAGD,OAAO,CAAC,eAAD,CAA1B;;AACA,IAAIE,aAAa,GAAGF,OAAO,CAAC,qBAAD,CAA3B;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,UAAT,CAAoBC,cAApB,EAAoC;AAChC,MAAIC,MAAM,GAAGC,SAAS,CAACD,MAAvB;AACA,MAAIE,SAAS,GAAGR,OAAO,CAACS,KAAxB;;AACA,MAAIN,aAAa,CAACO,WAAd,CAA0BH,SAAS,CAACA,SAAS,CAACD,MAAV,GAAmB,CAApB,CAAnC,CAAJ,EAAgE;AAC5DE,IAAAA,SAAS,GAAGD,SAAS,CAACA,SAAS,CAACD,MAAV,GAAmB,CAApB,CAArB;AACAA,IAAAA,MAAM;AACT;;AACD,MAAIK,sBAAsB,GAAG,IAA7B;;AACA,MAAIL,MAAM,IAAI,CAAd,EAAiB;AACbK,IAAAA,sBAAsB,GAAGJ,SAAS,CAAC,CAAD,CAAlC;AACH;;AACD,MAAIK,aAAa,GAAGC,MAAM,CAACC,iBAA3B;;AACA,MAAIR,MAAM,IAAI,CAAd,EAAiB;AACbM,IAAAA,aAAa,GAAGL,SAAS,CAAC,CAAD,CAAzB;AACH;;AACD,SAAO,SAASQ,0BAAT,CAAoCC,MAApC,EAA4C;AAC/C,WAAOA,MAAM,CAACC,IAAP,CAAY,IAAIC,kBAAJ,CAAuBb,cAAvB,EAAuCM,sBAAvC,EAA+DC,aAA/D,EAA8EJ,SAA9E,CAAZ,CAAP;AACH,GAFD;AAGH;;AACDW,OAAO,CAACf,UAAR,GAAqBA,UAArB;;AACA,IAAIc,kBAAkB,GAAI,YAAY;AAClC,WAASA,kBAAT,CAA4Bb,cAA5B,EAA4CM,sBAA5C,EAAoEC,aAApE,EAAmFJ,SAAnF,EAA8F;AAC1F,SAAKH,cAAL,GAAsBA,cAAtB;AACA,SAAKM,sBAAL,GAA8BA,sBAA9B;AACA,SAAKC,aAAL,GAAqBA,aAArB;AACA,SAAKJ,SAAL,GAAiBA,SAAjB;AACH;;AACDU,EAAAA,kBAAkB,CAACrB,SAAnB,CAA6BuB,IAA7B,GAAoC,UAAUC,UAAV,EAAsBL,MAAtB,EAA8B;AAC9D,WAAOA,MAAM,CAACM,SAAP,CAAiB,IAAIC,oBAAJ,CAAyBF,UAAzB,EAAqC,KAAKhB,cAA1C,EAA0D,KAAKM,sBAA/D,EAAuF,KAAKC,aAA5F,EAA2G,KAAKJ,SAAhH,CAAjB,CAAP;AACH,GAFD;;AAGA,SAAOU,kBAAP;AACH,CAXyB,EAA1B;;AAYA,IAAIM,OAAO,GAAI,YAAY;AACvB,WAASA,OAAT,GAAmB;AACf,SAAKC,MAAL,GAAc,EAAd;AACH;;AACD,SAAOD,OAAP;AACH,CALc,EAAf;AAMA;AACA;AACA;AACA;AACA;;;AACA,IAAID,oBAAoB,GAAI,UAAUG,MAAV,EAAkB;AAC1CpC,EAAAA,SAAS,CAACiC,oBAAD,EAAuBG,MAAvB,CAAT;;AACA,WAASH,oBAAT,CAA8BI,WAA9B,EAA2CtB,cAA3C,EAA2DM,sBAA3D,EAAmFC,aAAnF,EAAkGJ,SAAlG,EAA6G;AACzGkB,IAAAA,MAAM,CAACN,IAAP,CAAY,IAAZ,EAAkBO,WAAlB;;AACA,SAAKtB,cAAL,GAAsBA,cAAtB;AACA,SAAKM,sBAAL,GAA8BA,sBAA9B;AACA,SAAKC,aAAL,GAAqBA,aAArB;AACA,SAAKJ,SAAL,GAAiBA,SAAjB;AACA,SAAKoB,QAAL,GAAgB,EAAhB;AACA,QAAIC,OAAO,GAAG,KAAKC,WAAL,EAAd;AACA,SAAKC,YAAL,GAAoBpB,sBAAsB,IAAI,IAA1B,IAAkCA,sBAAsB,GAAG,CAA/E;;AACA,QAAI,KAAKoB,YAAT,EAAuB;AACnB,UAAIC,iBAAiB,GAAG;AAAEX,QAAAA,UAAU,EAAE,IAAd;AAAoBQ,QAAAA,OAAO,EAAEA,OAA7B;AAAsCxB,QAAAA,cAAc,EAAEA;AAAtD,OAAxB;AACA,WAAK4B,GAAL,CAASJ,OAAO,CAACK,WAAR,GAAsB1B,SAAS,CAAC2B,QAAV,CAAmBC,0BAAnB,EAA+C/B,cAA/C,EAA+D2B,iBAA/D,CAA/B;AACH,KAHD,MAIK;AACD,UAAIK,UAAU,GAAG;AAAEhB,QAAAA,UAAU,EAAE,IAAd;AAAoBQ,QAAAA,OAAO,EAAEA;AAA7B,OAAjB;AACA,UAAIS,aAAa,GAAG;AAAEjC,QAAAA,cAAc,EAAEA,cAAlB;AAAkCM,QAAAA,sBAAsB,EAAEA,sBAA1D;AAAkFU,QAAAA,UAAU,EAAE,IAA9F;AAAoGb,QAAAA,SAAS,EAAEA;AAA/G,OAApB;AACA,WAAKyB,GAAL,CAASJ,OAAO,CAACK,WAAR,GAAsB1B,SAAS,CAAC2B,QAAV,CAAmBI,mBAAnB,EAAwClC,cAAxC,EAAwDgC,UAAxD,CAA/B;AACA,WAAKJ,GAAL,CAASzB,SAAS,CAAC2B,QAAV,CAAmBK,sBAAnB,EAA2C7B,sBAA3C,EAAmE2B,aAAnE,CAAT;AACH;AACJ;;AACDf,EAAAA,oBAAoB,CAAC1B,SAArB,CAA+B4C,KAA/B,GAAuC,UAAUC,KAAV,EAAiB;AACpD,QAAId,QAAQ,GAAG,KAAKA,QAApB;AACA,QAAIe,GAAG,GAAGf,QAAQ,CAACtB,MAAnB;AACA,QAAIsC,mBAAJ;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAApB,EAAyBE,CAAC,EAA1B,EAA8B;AAC1B,UAAIhB,OAAO,GAAGD,QAAQ,CAACiB,CAAD,CAAtB;AACA,UAAIpB,MAAM,GAAGI,OAAO,CAACJ,MAArB;AACAA,MAAAA,MAAM,CAACqB,IAAP,CAAYJ,KAAZ;;AACA,UAAIjB,MAAM,CAACnB,MAAP,IAAiB,KAAKM,aAA1B,EAAyC;AACrCgC,QAAAA,mBAAmB,GAAGf,OAAtB;AACH;AACJ;;AACD,QAAIe,mBAAJ,EAAyB;AACrB,WAAKG,YAAL,CAAkBH,mBAAlB;AACH;AACJ,GAfD;;AAgBArB,EAAAA,oBAAoB,CAAC1B,SAArB,CAA+BmD,MAA/B,GAAwC,UAAUC,GAAV,EAAe;AACnD,SAAKrB,QAAL,CAActB,MAAd,GAAuB,CAAvB;;AACAoB,IAAAA,MAAM,CAAC7B,SAAP,CAAiBmD,MAAjB,CAAwB5B,IAAxB,CAA6B,IAA7B,EAAmC6B,GAAnC;AACH,GAHD;;AAIA1B,EAAAA,oBAAoB,CAAC1B,SAArB,CAA+BqD,SAA/B,GAA2C,YAAY;AACnD,QAAIC,EAAE,GAAG,IAAT;AAAA,QAAevB,QAAQ,GAAGuB,EAAE,CAACvB,QAA7B;AAAA,QAAuCD,WAAW,GAAGwB,EAAE,CAACxB,WAAxD;;AACA,WAAOC,QAAQ,CAACtB,MAAT,GAAkB,CAAzB,EAA4B;AACxB,UAAIuB,OAAO,GAAGD,QAAQ,CAACwB,KAAT,EAAd;AACAzB,MAAAA,WAAW,CAAC0B,IAAZ,CAAiBxB,OAAO,CAACJ,MAAzB;AACH;;AACDC,IAAAA,MAAM,CAAC7B,SAAP,CAAiBqD,SAAjB,CAA2B9B,IAA3B,CAAgC,IAAhC;AACH,GAPD;AAQA;;;AAAqCG,EAAAA,oBAAoB,CAAC1B,SAArB,CAA+ByD,YAA/B,GAA8C,YAAY;AAC3F,SAAK1B,QAAL,GAAgB,IAAhB;AACH,GAFoC;;AAGrCL,EAAAA,oBAAoB,CAAC1B,SAArB,CAA+BkD,YAA/B,GAA8C,UAAUlB,OAAV,EAAmB;AAC7D,SAAK0B,YAAL,CAAkB1B,OAAlB;AACA,QAAIK,WAAW,GAAGL,OAAO,CAACK,WAA1B;AACAA,IAAAA,WAAW,CAACsB,WAAZ;AACA,SAAKC,MAAL,CAAYvB,WAAZ;;AACA,QAAI,CAAC,KAAKwB,MAAN,IAAgB,KAAK3B,YAAzB,EAAuC;AACnCF,MAAAA,OAAO,GAAG,KAAKC,WAAL,EAAV;AACA,UAAIzB,cAAc,GAAG,KAAKA,cAA1B;AACA,UAAI2B,iBAAiB,GAAG;AAAEX,QAAAA,UAAU,EAAE,IAAd;AAAoBQ,QAAAA,OAAO,EAAEA,OAA7B;AAAsCxB,QAAAA,cAAc,EAAEA;AAAtD,OAAxB;AACA,WAAK4B,GAAL,CAASJ,OAAO,CAACK,WAAR,GAAsB,KAAK1B,SAAL,CAAe2B,QAAf,CAAwBC,0BAAxB,EAAoD/B,cAApD,EAAoE2B,iBAApE,CAA/B;AACH;AACJ,GAXD;;AAYAT,EAAAA,oBAAoB,CAAC1B,SAArB,CAA+BiC,WAA/B,GAA6C,YAAY;AACrD,QAAID,OAAO,GAAG,IAAIL,OAAJ,EAAd;AACA,SAAKI,QAAL,CAAckB,IAAd,CAAmBjB,OAAnB;AACA,WAAOA,OAAP;AACH,GAJD;;AAKAN,EAAAA,oBAAoB,CAAC1B,SAArB,CAA+B0D,YAA/B,GAA8C,UAAU1B,OAAV,EAAmB;AAC7D,SAAKF,WAAL,CAAiB0B,IAAjB,CAAsBxB,OAAO,CAACJ,MAA9B;AACA,QAAIG,QAAQ,GAAG,KAAKA,QAApB;AACA,QAAI+B,WAAW,GAAG/B,QAAQ,GAAGA,QAAQ,CAACgC,OAAT,CAAiB/B,OAAjB,CAAH,GAA+B,CAAC,CAA1D;;AACA,QAAI8B,WAAW,IAAI,CAAnB,EAAsB;AAClB/B,MAAAA,QAAQ,CAACiC,MAAT,CAAgBjC,QAAQ,CAACgC,OAAT,CAAiB/B,OAAjB,CAAhB,EAA2C,CAA3C;AACH;AACJ,GAPD;;AAQA,SAAON,oBAAP;AACH,CA/E2B,CA+E1BrB,YAAY,CAAC4D,UA/Ea,CAA5B;;AAgFA,SAAS1B,0BAAT,CAAoC2B,KAApC,EAA2C;AACvC,MAAI1C,UAAU,GAAG0C,KAAK,CAAC1C,UAAvB;AACA,MAAI2C,WAAW,GAAGD,KAAK,CAAClC,OAAxB;;AACA,MAAImC,WAAJ,EAAiB;AACb3C,IAAAA,UAAU,CAACkC,YAAX,CAAwBS,WAAxB;AACH;;AACD,MAAI,CAAC3C,UAAU,CAACqC,MAAhB,EAAwB;AACpBK,IAAAA,KAAK,CAAClC,OAAN,GAAgBR,UAAU,CAACS,WAAX,EAAhB;AACAiC,IAAAA,KAAK,CAAClC,OAAN,CAAcK,WAAd,GAA4B,KAAKC,QAAL,CAAc4B,KAAd,EAAqBA,KAAK,CAAC1D,cAA3B,CAA5B;AACH;AACJ;;AACD,SAASmC,sBAAT,CAAgCuB,KAAhC,EAAuC;AACnC,MAAIpD,sBAAsB,GAAGoD,KAAK,CAACpD,sBAAnC;AAAA,MAA2DN,cAAc,GAAG0D,KAAK,CAAC1D,cAAlF;AAAA,MAAkGgB,UAAU,GAAG0C,KAAK,CAAC1C,UAArH;AAAA,MAAiIb,SAAS,GAAGuD,KAAK,CAACvD,SAAnJ;AACA,MAAIqB,OAAO,GAAGR,UAAU,CAACS,WAAX,EAAd;AACA,MAAImC,MAAM,GAAG,IAAb;;AACA,MAAI,CAAC5C,UAAU,CAACqC,MAAhB,EAAwB;AACpBrC,IAAAA,UAAU,CAACY,GAAX,CAAeJ,OAAO,CAACK,WAAR,GAAsB1B,SAAS,CAAC2B,QAAV,CAAmBI,mBAAnB,EAAwClC,cAAxC,EAAwD;AAAEgB,MAAAA,UAAU,EAAEA,UAAd;AAA0BQ,MAAAA,OAAO,EAAEA;AAAnC,KAAxD,CAArC;AACAoC,IAAAA,MAAM,CAAC9B,QAAP,CAAgB4B,KAAhB,EAAuBpD,sBAAvB;AACH;AACJ;;AACD,SAAS4B,mBAAT,CAA6B2B,GAA7B,EAAkC;AAC9B,MAAI7C,UAAU,GAAG6C,GAAG,CAAC7C,UAArB;AAAA,MAAiCQ,OAAO,GAAGqC,GAAG,CAACrC,OAA/C;AACAR,EAAAA,UAAU,CAACkC,YAAX,CAAwB1B,OAAxB;AACH","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = require('../scheduler/async');\nvar Subscriber_1 = require('../Subscriber');\nvar isScheduler_1 = require('../util/isScheduler');\n/* tslint:enable:max-line-length */\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * <img src=\"./img/bufferTime.png\" width=\"100%\">\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * @example <caption>Every second, emit an array of the recent click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(1000);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(2000, 5000);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferTime\n * @owner Observable\n */\nfunction bufferTime(bufferTimeSpan) {\n    var length = arguments.length;\n    var scheduler = async_1.async;\n    if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {\n        scheduler = arguments[arguments.length - 1];\n        length--;\n    }\n    var bufferCreationInterval = null;\n    if (length >= 2) {\n        bufferCreationInterval = arguments[1];\n    }\n    var maxBufferSize = Number.POSITIVE_INFINITY;\n    if (length >= 3) {\n        maxBufferSize = arguments[2];\n    }\n    return function bufferTimeOperatorFunction(source) {\n        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n    };\n}\nexports.bufferTime = bufferTime;\nvar BufferTimeOperator = (function () {\n    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n    }\n    BufferTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n    };\n    return BufferTimeOperator;\n}());\nvar Context = (function () {\n    function Context() {\n        this.buffer = [];\n    }\n    return Context;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferTimeSubscriber = (function (_super) {\n    __extends(BufferTimeSubscriber, _super);\n    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        _super.call(this, destination);\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n        this.contexts = [];\n        var context = this.openContext();\n        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n        if (this.timespanOnly) {\n            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n        else {\n            var closeState = { subscriber: this, context: context };\n            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: this, scheduler: scheduler };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n        }\n    }\n    BufferTimeSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        var len = contexts.length;\n        var filledBufferContext;\n        for (var i = 0; i < len; i++) {\n            var context = contexts[i];\n            var buffer = context.buffer;\n            buffer.push(value);\n            if (buffer.length == this.maxBufferSize) {\n                filledBufferContext = context;\n            }\n        }\n        if (filledBufferContext) {\n            this.onBufferFull(filledBufferContext);\n        }\n    };\n    BufferTimeSubscriber.prototype._error = function (err) {\n        this.contexts.length = 0;\n        _super.prototype._error.call(this, err);\n    };\n    BufferTimeSubscriber.prototype._complete = function () {\n        var _a = this, contexts = _a.contexts, destination = _a.destination;\n        while (contexts.length > 0) {\n            var context = contexts.shift();\n            destination.next(context.buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    /** @deprecated internal use only */ BufferTimeSubscriber.prototype._unsubscribe = function () {\n        this.contexts = null;\n    };\n    BufferTimeSubscriber.prototype.onBufferFull = function (context) {\n        this.closeContext(context);\n        var closeAction = context.closeAction;\n        closeAction.unsubscribe();\n        this.remove(closeAction);\n        if (!this.closed && this.timespanOnly) {\n            context = this.openContext();\n            var bufferTimeSpan = this.bufferTimeSpan;\n            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\n            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n    };\n    BufferTimeSubscriber.prototype.openContext = function () {\n        var context = new Context();\n        this.contexts.push(context);\n        return context;\n    };\n    BufferTimeSubscriber.prototype.closeContext = function (context) {\n        this.destination.next(context.buffer);\n        var contexts = this.contexts;\n        var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n        if (spliceIndex >= 0) {\n            contexts.splice(contexts.indexOf(context), 1);\n        }\n    };\n    return BufferTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchBufferTimeSpanOnly(state) {\n    var subscriber = state.subscriber;\n    var prevContext = state.context;\n    if (prevContext) {\n        subscriber.closeContext(prevContext);\n    }\n    if (!subscriber.closed) {\n        state.context = subscriber.openContext();\n        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n    }\n}\nfunction dispatchBufferCreation(state) {\n    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;\n    var context = subscriber.openContext();\n    var action = this;\n    if (!subscriber.closed) {\n        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));\n        action.schedule(state, bufferCreationInterval);\n    }\n}\nfunction dispatchBufferClose(arg) {\n    var subscriber = arg.subscriber, context = arg.context;\n    subscriber.closeContext(context);\n}\n"]},"metadata":{},"sourceType":"script"}