{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar async_1 = require('../scheduler/async');\n\nvar isDate_1 = require('../util/isDate');\n\nvar Subscriber_1 = require('../Subscriber');\n\nvar TimeoutError_1 = require('../util/TimeoutError');\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * <img src=\"./img/timeout.png\" width=\"100%\">\n *\n * `timeout` operator accepts as an argument either a number or a Date.\n *\n * If number was provided, it returns an Observable that behaves like a source\n * Observable, unless there is a period of time where there is no value emitted.\n * So if you provide `100` as argument and first value comes after 50ms from\n * the moment of subscription, this value will be simply re-emitted by the resulting\n * Observable. If however after that 100ms passes without a second value being emitted,\n * stream will end with an error and source Observable will be unsubscribed.\n * These checks are performed throughout whole lifecycle of Observable - from the moment\n * it was subscribed to, until it completes or errors itself. Thus every value must be\n * emitted within specified period since previous value.\n *\n * If provided argument was Date, returned Observable behaves differently. It throws\n * if Observable did not complete before provided Date. This means that periods between\n * emission of particular values do not matter in this case. If Observable did not complete\n * before provided Date, source Observable will be unsubscribed. Other than that, resulting\n * stream behaves just as source Observable.\n *\n * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\n * when returned Observable will check if source stream emitted value or completed.\n *\n * @example <caption>Check if ticks are emitted within certain timespan</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(1100) // Let's use bigger timespan to be safe,\n *                       // since `interval` might fire a bit later then scheduled.\n * .subscribe(\n *     value => console.log(value), // Will emit numbers just as regular `interval` would.\n *     err => console.log(err) // Will never be called.\n * );\n *\n * seconds.timeout(900).subscribe(\n *     value => console.log(value), // Will never be called.\n *     err => console.log(err) // Will emit error before even first value is emitted,\n *                             // since it did not arrive within 900ms period.\n * );\n *\n * @example <caption>Use Date to check if Observable completed</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(new Date(\"December 17, 2020 03:24:00\"))\n * .subscribe(\n *     value => console.log(value), // Will emit values as regular `interval` would\n *                                  // until December 17, 2020 at 03:24:00.\n *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,\n *                             // since Observable did not complete by then.\n * );\n *\n * @see {@link timeoutWith}\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\n * @method timeout\n * @owner Observable\n */\n\n\nfunction timeout(due, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async_1.async;\n  }\n\n  var absoluteTimeout = isDate_1.isDate(due);\n  var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);\n  return function (source) {\n    return source.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError()));\n  };\n}\n\nexports.timeout = timeout;\n\nvar TimeoutOperator = function () {\n  function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {\n    this.waitFor = waitFor;\n    this.absoluteTimeout = absoluteTimeout;\n    this.scheduler = scheduler;\n    this.errorInstance = errorInstance;\n  }\n\n  TimeoutOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));\n  };\n\n  return TimeoutOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar TimeoutSubscriber = function (_super) {\n  __extends(TimeoutSubscriber, _super);\n\n  function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {\n    _super.call(this, destination);\n\n    this.absoluteTimeout = absoluteTimeout;\n    this.waitFor = waitFor;\n    this.scheduler = scheduler;\n    this.errorInstance = errorInstance;\n    this.action = null;\n    this.scheduleTimeout();\n  }\n\n  TimeoutSubscriber.dispatchTimeout = function (subscriber) {\n    subscriber.error(subscriber.errorInstance);\n  };\n\n  TimeoutSubscriber.prototype.scheduleTimeout = function () {\n    var action = this.action;\n\n    if (action) {\n      // Recycle the action if we've already scheduled one. All the production\n      // Scheduler Actions mutate their state/delay time and return themeselves.\n      // VirtualActions are immutable, so they create and return a clone. In this\n      // case, we need to set the action reference to the most recent VirtualAction,\n      // to ensure that's the one we clone from next time.\n      this.action = action.schedule(this, this.waitFor);\n    } else {\n      this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));\n    }\n  };\n\n  TimeoutSubscriber.prototype._next = function (value) {\n    if (!this.absoluteTimeout) {\n      this.scheduleTimeout();\n    }\n\n    _super.prototype._next.call(this, value);\n  };\n  /** @deprecated internal use only */\n\n\n  TimeoutSubscriber.prototype._unsubscribe = function () {\n    this.action = null;\n    this.scheduler = null;\n    this.errorInstance = null;\n  };\n\n  return TimeoutSubscriber;\n}(Subscriber_1.Subscriber);","map":{"version":3,"sources":["/app/node_modules/ng5-slider/node_modules/rxjs/operators/timeout.js"],"names":["__extends","d","b","p","hasOwnProperty","__","constructor","prototype","Object","create","async_1","require","isDate_1","Subscriber_1","TimeoutError_1","timeout","due","scheduler","async","absoluteTimeout","isDate","waitFor","now","Math","abs","source","lift","TimeoutOperator","TimeoutError","exports","errorInstance","call","subscriber","subscribe","TimeoutSubscriber","_super","destination","action","scheduleTimeout","dispatchTimeout","error","schedule","add","_next","value","_unsubscribe","Subscriber"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = require('../scheduler/async');\nvar isDate_1 = require('../util/isDate');\nvar Subscriber_1 = require('../Subscriber');\nvar TimeoutError_1 = require('../util/TimeoutError');\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * <img src=\"./img/timeout.png\" width=\"100%\">\n *\n * `timeout` operator accepts as an argument either a number or a Date.\n *\n * If number was provided, it returns an Observable that behaves like a source\n * Observable, unless there is a period of time where there is no value emitted.\n * So if you provide `100` as argument and first value comes after 50ms from\n * the moment of subscription, this value will be simply re-emitted by the resulting\n * Observable. If however after that 100ms passes without a second value being emitted,\n * stream will end with an error and source Observable will be unsubscribed.\n * These checks are performed throughout whole lifecycle of Observable - from the moment\n * it was subscribed to, until it completes or errors itself. Thus every value must be\n * emitted within specified period since previous value.\n *\n * If provided argument was Date, returned Observable behaves differently. It throws\n * if Observable did not complete before provided Date. This means that periods between\n * emission of particular values do not matter in this case. If Observable did not complete\n * before provided Date, source Observable will be unsubscribed. Other than that, resulting\n * stream behaves just as source Observable.\n *\n * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\n * when returned Observable will check if source stream emitted value or completed.\n *\n * @example <caption>Check if ticks are emitted within certain timespan</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(1100) // Let's use bigger timespan to be safe,\n *                       // since `interval` might fire a bit later then scheduled.\n * .subscribe(\n *     value => console.log(value), // Will emit numbers just as regular `interval` would.\n *     err => console.log(err) // Will never be called.\n * );\n *\n * seconds.timeout(900).subscribe(\n *     value => console.log(value), // Will never be called.\n *     err => console.log(err) // Will emit error before even first value is emitted,\n *                             // since it did not arrive within 900ms period.\n * );\n *\n * @example <caption>Use Date to check if Observable completed</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(new Date(\"December 17, 2020 03:24:00\"))\n * .subscribe(\n *     value => console.log(value), // Will emit values as regular `interval` would\n *                                  // until December 17, 2020 at 03:24:00.\n *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,\n *                             // since Observable did not complete by then.\n * );\n *\n * @see {@link timeoutWith}\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\n * @method timeout\n * @owner Observable\n */\nfunction timeout(due, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    var absoluteTimeout = isDate_1.isDate(due);\n    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\n    return function (source) { return source.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError())); };\n}\nexports.timeout = timeout;\nvar TimeoutOperator = (function () {\n    function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {\n        this.waitFor = waitFor;\n        this.absoluteTimeout = absoluteTimeout;\n        this.scheduler = scheduler;\n        this.errorInstance = errorInstance;\n    }\n    TimeoutOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));\n    };\n    return TimeoutOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TimeoutSubscriber = (function (_super) {\n    __extends(TimeoutSubscriber, _super);\n    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {\n        _super.call(this, destination);\n        this.absoluteTimeout = absoluteTimeout;\n        this.waitFor = waitFor;\n        this.scheduler = scheduler;\n        this.errorInstance = errorInstance;\n        this.action = null;\n        this.scheduleTimeout();\n    }\n    TimeoutSubscriber.dispatchTimeout = function (subscriber) {\n        subscriber.error(subscriber.errorInstance);\n    };\n    TimeoutSubscriber.prototype.scheduleTimeout = function () {\n        var action = this.action;\n        if (action) {\n            // Recycle the action if we've already scheduled one. All the production\n            // Scheduler Actions mutate their state/delay time and return themeselves.\n            // VirtualActions are immutable, so they create and return a clone. In this\n            // case, we need to set the action reference to the most recent VirtualAction,\n            // to ensure that's the one we clone from next time.\n            this.action = action.schedule(this, this.waitFor);\n        }\n        else {\n            this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));\n        }\n    };\n    TimeoutSubscriber.prototype._next = function (value) {\n        if (!this.absoluteTimeout) {\n            this.scheduleTimeout();\n        }\n        _super.prototype._next.call(this, value);\n    };\n    /** @deprecated internal use only */ TimeoutSubscriber.prototype._unsubscribe = function () {\n        this.action = null;\n        this.scheduler = null;\n        this.errorInstance = null;\n    };\n    return TimeoutSubscriber;\n}(Subscriber_1.Subscriber));\n"]},"metadata":{},"sourceType":"script"}