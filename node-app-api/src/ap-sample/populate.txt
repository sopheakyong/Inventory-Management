router.get('/posts',authenticate, async (req,res) => {
    //const _ispublished = req.query.published;
    const match = {}

    if(req.query.published){
        match.published = req.query.published === 'true'
    }
    try {
        await req.user.populate({
            path:'posts',
            match
        }).execPopulate()
        res.send(req.user.posts)
    } catch (error) {
        res.status(500).send()
    }
})



router.get('/posts',authenticate, async (req,res) => {
    //const _ispublished = req.query.published;
    const match = {}

    if(req.query.published){
        match.published = req.query.published === 'true'
    }
    try {
        await req.user.populate({
            path:'posts',
            match,
            options:{
                limit: parseInt(req.query.limit),
                skip: parseInt(req.query.skip)
            }
        }).execPopulate()
        res.send(req.user.posts)
    } catch (error) {
        res.status(500).send()
    }
})


options:{
               sort:{
                  createdAt : -1 //descending order
               }
           }

// OR

options:{
               sort:{
                  createdAt : 1 // ascending order
               }
           }



    router.get('/posts',authenticate, async (req,res) => {
    //const _ispublished = req.query.published;
    const match = {}
    const sort  = {}

    if(req.query.published){
        match.published = req.query.published === 'true'
    }

    if(req.query.sortBy && req.query.OrderBy){
        sort[req.query.sortBy]   = req.query.OrderBy === 'desc' ? -1 : 1
    }

    try {
        await req.user.populate({
            path:'posts',
            match,
            options:{
                limit: parseInt(req.query.limit),
                skip: parseInt(req.query.skip),
                sort
            }
        }).execPopulate()
        res.send(req.user.posts)
    } catch (error) {
        res.status(500).send()
    }
})
view raw
